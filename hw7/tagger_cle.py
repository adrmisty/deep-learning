#!/usr/bin/env python3
#cc1d5497-f262-4cfd-b538-a12d2b403848 - Rodríguez Flórez Adriana
#fc0aa991-f366-44b1-992d-2c70e9f7a995 - Ahmadi AbdulAli
#a436e2ea-25cf-4f36-8ee9-d81ff6c9f813 - Korol Andrii
import argparse
import datetime
import os
import re

import torch
import torchmetrics

import npfl138
npfl138.require_version("2425.7.2")
from npfl138.datasets.morpho_dataset import MorphoDataset

parser = argparse.ArgumentParser()
# These arguments will be set appropriately by ReCodEx, even if you change them.
parser.add_argument("--batch_size", default=10, type=int, help="Batch size.")
parser.add_argument("--cle_dim", default=32, type=int, help="CLE embedding dimension.")
parser.add_argument("--epochs", default=5, type=int, help="Number of epochs.")
parser.add_argument("--max_sentences", default=5000, type=int, help="Maximum number of sentences to load.")
parser.add_argument("--recodex", default=False, action="store_true", help="Evaluation in ReCodEx.")
parser.add_argument("--rnn", default="GRU", choices=["LSTM", "GRU"], help="RNN layer type.")
parser.add_argument("--rnn_dim", default=32, type=int, help="RNN layer dimension.")
parser.add_argument("--seed", default=42, type=int, help="Random seed.")
parser.add_argument("--threads", default=1, type=int, help="Maximum number of threads to use.")
parser.add_argument("--we_dim", default=64, type=int, help="Word embedding dimension.")
parser.add_argument("--word_masking", default=0.1, type=float, help="Mask words with the given probability.")

class Model(npfl138.TrainableModule):
    class MaskElements(torch.nn.Module):
        def __init__(self, mask_probability, mask_value):
            super().__init__()
            self._mask_probability = mask_probability
            self._mask_value = mask_value

        def forward(self, inputs: torch.Tensor) -> torch.Tensor:
            
            if self.training and self._mask_probability:
                # TODO: Generate a mask tensor of `torch.float32`s of the same shape
                # as `inputs` using either `torch.rand` or `torch.rand_like`.
                # Then replace the inputs elements whose mask value is less than
                # `self._mask_probability` with the value of `self._mask_value`.
                mask = torch.rand_like(inputs, dtype=torch.float32) < self._mask_probability
                inputs = torch.where(mask, torch.tensor(self._mask_value, device=inputs.device), inputs)
            return inputs

    def __init__(self, args: argparse.Namespace, train: MorphoDataset.Dataset) -> None:
        super().__init__()
        # Create all needed layers.
        # TODO: Create a word masking layer `self.MaskElements` with the given
        # `args.word_masking` probability and `MorphoDataset.UNK` as the masking value.

        #self._word_masking = self.MaskElements(args.word_masking, train.words.string_vocab.lookup(MorphoDataset.UNK))
        self._word_masking = self.MaskElements(args.word_masking, train.words.string_vocab.index(MorphoDataset.UNK))
        
        # TODO: Create a `torch.nn.Embedding` layer for embedding the character ids
        # from `train.words.char_vocab` to dimensionality `args.cle_dim`.
        self._char_embedding = torch.nn.Embedding(len(train.words.char_vocab), args.cle_dim)
        
        # TODO: Create a bidirectional `torch.nn.GRU` layer processing the character
        # embeddings, producing output of dimensionality `args.cle_dim`; again, also pass
        # `batch_first=True` to the constructor.
        self._char_rnn = torch.nn.GRU(args.cle_dim, args.cle_dim, bidirectional=True, batch_first=True)
        
        # TODO(tagger_we): Create a `torch.nn.Embedding` layer, embedding the word ids
        # from `train.words.string_vocab` to dimensionality `args.we_dim`.
        self._word_embedding = torch.nn.Embedding(len(train.words.string_vocab), args.we_dim)
        
        # TODO: Create an RNN layer, either `torch.nn.LSTM` or `torch.nn.GRU` depending
        # on `args.rnn`. The layer should be bidirectional (`bidirectional=True`) with
        # dimensionality `args.rnn_dim`, and you should also pass `batch_first=True` to
        # the constructor. In the forward pass, the layer will process the word embeddings
        # generated by the `self._word_embedding` layer, **now concatenated with the
        # character-level embeddings**, and we will sum the forward and backward outputs.
        rnn_cls = torch.nn.LSTM if args.rnn == "LSTM" else torch.nn.GRU
        self._word_rnn = rnn_cls(args.we_dim + 2 * args.cle_dim, args.rnn_dim, bidirectional=True, batch_first=True)
        
        # TODO(tagger_we): Create an output linear layer (`torch.nn.Linear`) processing the RNN output,
        # producing logits for tag prediction; `train.tags.string_vocab` is the tag vocabulary.

        #self._output_layer = torch.nn.Linear(2 * args.rnn_dim, len(train.tags.string_vocab))
        self._output_layer = torch.nn.Linear(args.rnn_dim, len(train.tags.string_vocab))


    def forward(self, word_ids: torch.Tensor, unique_words: torch.Tensor, word_indices: torch.Tensor) -> torch.Tensor:
        # TODO: Mask the input `word_ids` using the `self._word_masking` layer.
        hidden = self._word_masking(word_ids)
        
        # TODO: Embed the masked word IDs in `hidden` using the word embedding layer.
        word_embedded = self._word_embedding(hidden)
        
        # TODO: Embed the `unique_words` using the character embedding layer.
        cle_embedded = self._char_embedding(unique_words)
        
        # TODO: Pass the `PackedSequence` through the character RNN, obtaining fixed-size
        # representation of every unique word in the batch. Then, concatenate the states
        # of the forward and backward directions (in this order).

        # With `cle` being the character-level embeddings of the unique words
        # of shape `[num_unique_words, 2 * cle_dim]`, create the representation of the
        # (not necessary unique) sentence words by indexing the character-level
        # embeddings with the `word_indices`. The result should have a shape
        # `[batch_size, max_sentence_length, 2 * cle_dim]`. You can use for example
        # the `torch.nn.functional.embedding` function.
        packed = torch.nn.utils.rnn.pack_padded_sequence(cle_embedded, lengths=(unique_words != MorphoDataset.PAD).sum(dim=1).cpu(), batch_first=True, enforce_sorted=False)
        _, states = self._char_rnn(packed)

        if isinstance(states, tuple):
            states = states[0]
            
        cle = torch.cat([states[-2], states[-1]], dim=1)
        cle = torch.nn.functional.embedding(word_indices, cle)

        hidden = torch.cat([word_embedded, cle], dim=2)

        
        # TODO(tagger_we): Process the embeddings through the RNN layer. Because the sentences
        # have different length, you have to use `torch.nn.utils.rnn.pack_padded_sequence`
        # to construct a variable-length `PackedSequence` from the input. You need to compute
        # the length of each sentence in the batch (by counting non-`MorphoDataset.PAD` tokens);
        # note that these lengths must be on CPU, so you might need to use the `.cpu()` method.
        # Finally, also pass `batch_first=True` and `enforce_sorted=False` to the call.    
        # (tagger_we): Unpack the RNN output using the `torch.nn.utils.rnn.pad_packed_sequence` with
        # `batch_first=True` argument. Then sum the outputs of forward and backward directions.
        sentence_lengths = (word_ids != MorphoDataset.PAD).sum(dim=1).cpu()
        packed = torch.nn.utils.rnn.pack_padded_sequence(hidden, sentence_lengths, batch_first=True, enforce_sorted=False)
        packed_output, _ = self._word_rnn(packed)
        
        # TODO(tagger_we): Pass the RNN output through the output layer. Such an output has a shape
        # `[batch_size, sequence_length, num_tags]`, but the loss and the metric expect
        # the `num_tags` dimension to be in front (`[batch_size, num_tags, sequence_length]`),
        # so you need to reorder the dimensions.
        hidden, _ = torch.nn.utils.rnn.pad_packed_sequence(packed_output, batch_first=True)

        hidden = hidden[:, :, :self._word_rnn.hidden_size] + hidden[:, :, self._word_rnn.hidden_size:]
        hidden = self._output_layer(hidden)
        hidden = hidden.permute(0, 2, 1)

        return hidden

class TrainableDataset(npfl138.TransformedDataset):
    def transform(self, example):
        word_ids = torch.tensor([self.dataset.words.string_vocab.index(word) for word in example["words"]], dtype=torch.long)
        tag_ids = torch.tensor([self.dataset.tags.string_vocab.index(tag) for tag in example["tags"]], dtype=torch.long)
        return word_ids, example["words"], tag_ids


    def collate(self, batch):
        word_ids, words, tag_ids = zip(*batch)
        word_ids = torch.nn.utils.rnn.pad_sequence(word_ids, batch_first=True, padding_value=MorphoDataset.PAD)
        unique_words, word_indices = self.dataset.cle_batch(words)
        tag_ids = torch.nn.utils.rnn.pad_sequence(tag_ids, batch_first=True, padding_value=MorphoDataset.PAD)
        return (word_ids, unique_words, word_indices), tag_ids

def main(args: argparse.Namespace) -> dict[str, float]:
    npfl138.startup(args.seed, args.threads)
    npfl138.global_keras_initializers()

    args.logdir = os.path.join("logs", "{}-{}-{}".format(
        os.path.basename(globals().get("__file__", "notebook")),
        datetime.datetime.now().strftime("%Y-%m-%d_%H%M%S"),
        ",".join(("{}={}".format(re.sub("(.)[^_]*_?", r"\1", k), v) for k, v in sorted(vars(args).items())))
    ))

    morpho = MorphoDataset("czech_cac", max_sentences=args.max_sentences)

    train = TrainableDataset(morpho.train).dataloader(batch_size=args.batch_size, shuffle=True)
    dev = TrainableDataset(morpho.dev).dataloader(batch_size=args.batch_size)

    model = Model(args, morpho.train)

    model.configure(
        # TODO(tagger_we): Create the Adam optimizer.
        optimizer=torch.optim.Adam(model.parameters()),
        # TODO(tagge_we): Use the usual `torch.nn.CrossEntropyLoss` loss function. Additionally,
        # pass `ignore_index=morpho.PAD` to the constructor so that the padded
        # tags are ignored during the loss computation. Note that the loss
        # expects the input to be of shape `[batch_size, num_tags, sequence_length]`.
        loss=torch.nn.CrossEntropyLoss(ignore_index=MorphoDataset.PAD),
        # TODO(tagger_we): Create a `torchmetrics.Accuracy` metric, passing "multiclass" as
        # the first argument, `num_classes` set to the number of unique tags, and
        # again `ignore_index=morpho.PAD` to ignore the padded tags.
        metrics={"accuracy": torchmetrics.Accuracy(task="multiclass", num_classes=len(morpho.train.tags.string_vocab), ignore_index=MorphoDataset.PAD)},
        logdir=args.logdir,
    )

    logs = model.fit(train, dev=dev, epochs=args.epochs)

    return {metric: value for metric, value in logs.items() if metric.startswith("dev_")}

if __name__ == "__main__":
    main_args = parser.parse_args([] if "__file__" not in globals() else None)
    main(main_args)
